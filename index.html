<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singing Key Detector - Piano Learning Mode</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Key Detector">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="description" content="Detect musical keys with your voice using visual piano keyboard">
    
    <!-- Permissions -->
    <meta http-equiv="Permissions-Policy" content="microphone=*">
    
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=DM+Serif+Display&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            font-family: 'DM Serif Display', serif;
            font-size: clamp(2rem, 5vw, 3.5rem);
            text-align: center;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00d4ff, #7b2ff7, #f1c40f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 8s ease infinite;
            background-size: 200% 200%;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #a0a0a0;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 14px 28px;
            font-family: 'Space Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-start {
            background: transparent;
            border-color: #00d4ff;
            color: #00d4ff;
        }

        .btn-start:hover {
            background: #00d4ff;
            color: #1a1a2e;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .btn-stop {
            background: transparent;
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .btn-stop:hover {
            background: #ff6b6b;
            color: #1a1a2e;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        .btn-reset {
            background: transparent;
            border-color: #f1c40f;
            color: #f1c40f;
        }

        .btn-reset:hover {
            background: #f1c40f;
            color: #1a1a2e;
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
        }

        .status {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 30px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 12px;
            border: 2px solid;
        }

        .status.listening {
            background: rgba(0, 212, 255, 0.1);
            border-color: #00d4ff;
            color: #00d4ff;
            animation: pulse 2s ease infinite;
        }

        .status.stopped {
            background: rgba(255, 107, 107, 0.1);
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Piano Keyboard */
        .piano-section {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 40px 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .piano-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .piano-header h2 {
            font-family: 'DM Serif Display', serif;
            font-size: 1.8rem;
            margin-bottom: 8px;
            color: #00d4ff;
        }

        .piano-instructions {
            color: #a0a0a0;
            font-size: 12px;
            letter-spacing: 1px;
        }

        .piano-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 0 auto;
            max-width: 900px;
            perspective: 1000px;
        }

        .piano {
            display: flex;
            position: relative;
            padding: 20px;
            background: linear-gradient(180deg, #2d2d2d 0%, #1a1a1a 100%);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .octave {
            display: flex;
            position: relative;
        }

        .key {
            position: relative;
            user-select: none;
            transition: all 0.1s ease;
        }

        .white-key {
            width: 50px;
            height: 200px;
            background: linear-gradient(180deg, #ffffff 0%, #f0f0f0 100%);
            border: 2px solid #222;
            border-radius: 0 0 6px 6px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 10px;
        }

        .white-key:hover {
            background: linear-gradient(180deg, #f8f8f8 0%, #e8e8e8 100%);
        }

        .white-key.active {
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.8), 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(2px);
            animation: keyGlow 0.3s ease;
        }

        @keyframes keyGlow {
            0%, 100% { box-shadow: 0 0 30px rgba(0, 212, 255, 0.8); }
            50% { box-shadow: 0 0 50px rgba(0, 212, 255, 1); }
        }

        .black-key {
            position: absolute;
            width: 32px;
            height: 120px;
            background: linear-gradient(180deg, #1a1a1a 0%, #000000 100%);
            border: 2px solid #000;
            border-radius: 0 0 4px 4px;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 8px;
        }

        .black-key:hover {
            background: linear-gradient(180deg, #2a2a2a 0%, #0a0a0a 100%);
        }

        .black-key.active {
            background: linear-gradient(135deg, #7b2ff7 0%, #5a1fb7 100%);
            box-shadow: 0 0 30px rgba(123, 47, 247, 0.8), 0 4px 8px rgba(0, 0, 0, 0.6);
            transform: translateY(2px);
        }

        .key-label {
            font-size: 11px;
            font-weight: 700;
            color: #666;
            letter-spacing: 0.5px;
        }

        .white-key.active .key-label {
            color: #fff;
        }

        .black-key .key-label {
            color: #888;
            font-size: 10px;
        }

        .black-key.active .key-label {
            color: #fff;
        }

        /* Position black keys */
        .black-key[data-note="C#"] { left: 35px; }
        .black-key[data-note="D#"] { left: 87px; }
        .black-key[data-note="F#"] { left: 191px; }
        .black-key[data-note="G#"] { left: 243px; }
        .black-key[data-note="A#"] { left: 295px; }

        /* Info Grid */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 24px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .info-card:hover {
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .info-label {
            font-size: 11px;
            color: #a0a0a0;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .info-value {
            font-size: 2rem;
            font-weight: 700;
            color: #00d4ff;
            font-family: 'DM Serif Display', serif;
        }

        .key-display {
            font-size: 3rem !important;
        }

        .note-trail {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            max-height: 200px;
            overflow-y: auto;
        }

        .note-trail h3 {
            font-size: 14px;
            color: #00d4ff;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .note-trail-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .note-bubble {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            color: #00d4ff;
            animation: bubbleIn 0.3s ease;
        }

        @keyframes bubbleIn {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Custom Scrollbar */
        .note-trail::-webkit-scrollbar {
            width: 6px;
        }

        .note-trail::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .note-trail::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 3px;
        }

        .learning-tip {
            background: rgba(241, 196, 15, 0.1);
            border: 2px solid #f1c40f;
            border-radius: 12px;
            padding: 16px;
            margin-top: 20px;
            text-align: center;
        }

        .learning-tip-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .learning-tip-text {
            color: #f1c40f;
            font-size: 13px;
            line-height: 1.6;
        }

        .confidence-bar {
            width: 100%;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            margin-top: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff 0%, #7b2ff7 50%, #f1c40f 100%);
            transition: width 0.3s ease;
            width: 0%;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: rgba(0, 212, 255, 0.95);
            color: #1a1a2e;
            padding: 16px 32px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 14px;
            letter-spacing: 1px;
            text-transform: uppercase;
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.4);
            z-index: 1000;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 212, 255, 0.3);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .toast-icon {
            display: inline-block;
            margin-right: 8px;
            animation: bounce 0.6s ease;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        @media (max-width: 768px) {
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 2px solid #00d4ff;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.lock {
            background: rgba(241, 196, 15, 0.95);
            border-color: #f1c40f;
            box-shadow: 0 10px 40px rgba(241, 196, 15, 0.4);
        }

        .toast-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 18px;
        }

        .key-locked-indicator {
            display: inline-block;
            background: rgba(241, 196, 15, 0.2);
            border: 2px solid #f1c40f;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 10px;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: lockPulse 2s ease infinite;
        }

        @keyframes lockPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @media (max-width: 768px) {
            .piano {
                transform: scale(0.7);
                transform-origin: top center;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¹ Singing Key Detector</h1>
        <p class="subtitle">Visual Piano Learning Mode</p>

        <!-- Toast Notification -->
        <div id="toast" class="toast">
            <span class="toast-icon">ðŸŽµ</span>
            <span id="toastMessage">Message</span>
        </div>

        <div id="status" class="status stopped">Ready to start</div>

        <div class="controls">
            <button id="startButton" class="btn btn-start">Start Listening</button>
            <button id="stopButton" class="btn btn-stop" style="display: none;">Stop Listening</button>
            <button id="resetButton" class="btn btn-reset" style="display: none;">New Song</button>
        </div>

        <div class="piano-section">
            <div class="piano-header">
                <h2>Visual Keyboard</h2>
                <p class="piano-instructions">Watch the keys light up as you sing!</p>
            </div>
            <div class="piano-container">
                <div class="piano">
                    <div class="octave" id="piano">
                        <!-- C -->
                        <div class="key white-key" data-note="C">
                            <span class="key-label">C</span>
                        </div>
                        <!-- C# -->
                        <div class="key black-key" data-note="C#">
                            <span class="key-label">C#</span>
                        </div>
                        <!-- D -->
                        <div class="key white-key" data-note="D">
                            <span class="key-label">D</span>
                        </div>
                        <!-- D# -->
                        <div class="key black-key" data-note="D#">
                            <span class="key-label">D#</span>
                        </div>
                        <!-- E -->
                        <div class="key white-key" data-note="E">
                            <span class="key-label">E</span>
                        </div>
                        <!-- F -->
                        <div class="key white-key" data-note="F">
                            <span class="key-label">F</span>
                        </div>
                        <!-- F# -->
                        <div class="key black-key" data-note="F#">
                            <span class="key-label">F#</span>
                        </div>
                        <!-- G -->
                        <div class="key white-key" data-note="G">
                            <span class="key-label">G</span>
                        </div>
                        <!-- G# -->
                        <div class="key black-key" data-note="G#">
                            <span class="key-label">G#</span>
                        </div>
                        <!-- A -->
                        <div class="key white-key" data-note="A">
                            <span class="key-label">A</span>
                        </div>
                        <!-- A# -->
                        <div class="key black-key" data-note="A#">
                            <span class="key-label">A#</span>
                        </div>
                        <!-- B -->
                        <div class="key white-key" data-note="B">
                            <span class="key-label">B</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="info-grid">
            <div class="info-card">
                <div class="info-label">Detected Key</div>
                <div class="info-value key-display" id="detectedKey">--</div>
            </div>
            <div class="info-card">
                <div class="info-label">Current Chord</div>
                <div class="info-value" id="currentChord">--</div>
            </div>
            <div class="info-card">
                <div class="info-label">Current Note</div>
                <div class="info-value" id="currentNote">--</div>
            </div>
            <div class="info-card">
                <div class="info-label">Frequency</div>
                <div class="info-value" id="frequency">-- Hz</div>
            </div>
        </div>

        <div class="info-card" style="margin-bottom: 30px;">
            <div class="info-label">Confidence</div>
            <div class="info-value" id="confidence">--%</div>
            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFill"></div>
            </div>
        </div>

        <div class="note-trail">
            <h3>Note History</h3>
            <div class="note-trail-list" id="noteTrailList"></div>
        </div>

        <div class="learning-tip">
            <div class="learning-tip-icon">ðŸ’¡</div>
            <div class="learning-tip-text">
                <strong>Beginner Tip:</strong> Sing or play chords and watch multiple keys light up together! 
                The app detects common chords (C, Am, G7, etc.) and shows you which keys to press. 
                Perfect for learning chord progressions visually!
            </div>
        </div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        let scriptProcessor;
        let noteHistory = [];
        let noteFrequencies = {};
        let isListening = false;
        let lastSoundTime = Date.now();
        let silenceThreshold = 5000; // Increased to 5 seconds
        let currentActiveKey = null;
        let keyTimeouts = {};
        let recentNotes = []; // Track notes in a sliding window for chord detection
        let detectedKeyLocked = false; // Lock key detection at high confidence
        let lockedKey = null; // Store the locked key
        let lockedKeyConfidence = 0; // Store confidence of locked key

        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        // Chord definitions - notes that make up each chord
        const chordDefinitions = {
            // Major Chords
            "C": ["C", "E", "G"],
            "C#": ["C#", "F", "G#"],
            "D": ["D", "F#", "A"],
            "D#": ["D#", "G", "A#"],
            "E": ["E", "G#", "B"],
            "F": ["F", "A", "C"],
            "F#": ["F#", "A#", "C#"],
            "G": ["G", "B", "D"],
            "G#": ["G#", "C", "D#"],
            "A": ["A", "C#", "E"],
            "A#": ["A#", "D", "F"],
            "B": ["B", "D#", "F#"],
            
            // Minor Chords
            "Cm": ["C", "D#", "G"],
            "C#m": ["C#", "E", "G#"],
            "Dm": ["D", "F", "A"],
            "D#m": ["D#", "F#", "A#"],
            "Em": ["E", "G", "B"],
            "Fm": ["F", "G#", "C"],
            "F#m": ["F#", "A", "C#"],
            "Gm": ["G", "A#", "D"],
            "G#m": ["G#", "B", "D#"],
            "Am": ["A", "C", "E"],
            "A#m": ["A#", "C#", "F"],
            "Bm": ["B", "D", "F#"],
            
            // 7th Chords
            "C7": ["C", "E", "G", "A#"],
            "D7": ["D", "F#", "A", "C"],
            "E7": ["E", "G#", "B", "D"],
            "F7": ["F", "A", "C", "D#"],
            "G7": ["G", "B", "D", "F"],
            "A7": ["A", "C#", "E", "G"],
            "B7": ["B", "D#", "F#", "A"],
            
            // Diminished
            "Cdim": ["C", "D#", "F#"],
            "Ddim": ["D", "F", "G#"],
            "Edim": ["E", "G", "A#"],
            "Fdim": ["F", "G#", "B"],
            "Gdim": ["G", "A#", "C#"],
            "Adim": ["A", "C", "D#"],
            "Bdim": ["B", "D", "F"]
        };
        
        const keySignatures = {
            "C Major": ["C", "D", "E", "F", "G", "A", "B"],
            "G Major": ["G", "A", "B", "C", "D", "E", "F#"],
            "D Major": ["D", "E", "F#", "G", "A", "B", "C#"],
            "A Major": ["A", "B", "C#", "D", "E", "F#", "G#"],
            "E Major": ["E", "F#", "G#", "A", "B", "C#", "D#"],
            "B Major": ["B", "C#", "D#", "E", "F#", "G#", "A#"],
            "F# Major": ["F#", "G#", "A#", "B", "C#", "D#", "E#"],
            "F Major": ["F", "G", "A", "A#", "C", "D", "E"],
            "Bb Major": ["A#", "C", "D", "D#", "F", "G", "A"],
            "Eb Major": ["D#", "F", "G", "G#", "A#", "C", "D"],
            "Ab Major": ["G#", "A#", "C", "C#", "D#", "F", "G"],
            "Db Major": ["C#", "D#", "F", "F#", "G#", "A#", "C"],
            "A Minor": ["A", "B", "C", "D", "E", "F", "G"],
            "E Minor": ["E", "F#", "G", "A", "B", "C", "D"],
            "B Minor": ["B", "C#", "D", "E", "F#", "G", "A"],
            "D Minor": ["D", "E", "F", "G", "A", "A#", "C"],
            "G Minor": ["G", "A", "A#", "C", "D", "D#", "F"],
            "C Minor": ["C", "D", "D#", "F", "G", "G#", "A#"]
        };

        document.getElementById('startButton').addEventListener('click', startListening);
        document.getElementById('stopButton').addEventListener('click', stopListening);
        document.getElementById('resetButton').addEventListener('click', resetDetection);

        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2500);
        }

        function resetDetection() {
            noteHistory = [];
            noteFrequencies = {};
            recentNotes = [];
            lastSoundTime = Date.now();
            detectedKeyLocked = false;
            lockedKey = null;
            lockedKeyConfidence = 0;
            document.getElementById('noteTrailList').innerHTML = '';
            document.getElementById('detectedKey').textContent = '--';
            document.getElementById('currentNote').textContent = '--';
            document.getElementById('currentChord').textContent = '--';
            document.getElementById('frequency').textContent = '-- Hz';
            document.getElementById('confidence').textContent = '--%';
            document.getElementById('confidenceFill').style.width = '0%';
            clearAllActiveKeys();
            showToast('Reset - Ready for new song!');
        }

        async function startListening() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);

                analyser.smoothingTimeConstant = 0.8;
                analyser.fftSize = 2048;

                microphone.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                
                scriptProcessor.onaudioprocess = processAudio;

                isListening = true;
                noteHistory = [];
                noteFrequencies = {};
                recentNotes = [];
                lastSoundTime = Date.now();
                detectedKeyLocked = false;
                lockedKey = null;
                lockedKeyConfidence = 0;
                
                document.getElementById('startButton').style.display = 'none';
                document.getElementById('stopButton').style.display = 'block';
                document.getElementById('resetButton').style.display = 'block';
                document.getElementById('status').textContent = 'Listening...';
                document.getElementById('status').className = 'status listening';
            } catch (err) {
                alert('Error accessing microphone: ' + err.message);
            }
        }

        function stopListening() {
            if (microphone) {
                microphone.disconnect();
                scriptProcessor.disconnect();
                analyser.disconnect();
                audioContext.close();
                isListening = false;

                document.getElementById('startButton').style.display = 'block';
                document.getElementById('stopButton').style.display = 'none';
                document.getElementById('resetButton').style.display = 'none';
                document.getElementById('status').textContent = 'Stopped';
                document.getElementById('status').className = 'status stopped';
                clearAllActiveKeys();
            }
        }

        function processAudio() {
            const buffer = new Float32Array(2048);
            analyser.getFloatTimeDomainData(buffer);
            
            const frequency = autoCorrelate(buffer, audioContext.sampleRate);
            
            if (frequency > 0) {
                const note = frequencyToNote(frequency);
                const confidence = calculateConfidence(buffer);
                
                updateDisplay(note, frequency, confidence);
                
                // Add to recent notes for chord detection
                recentNotes.push(note);
                if (recentNotes.length > 10) {
                    recentNotes.shift();
                }
                
                // Detect and display chord
                const chord = detectChord(recentNotes);
                if (chord) {
                    document.getElementById('currentChord').textContent = chord;
                    highlightChordKeys(chord);
                } else {
                    highlightKey(note);
                }
                
                if (confidence > 0.5) {
                    const now = Date.now();
                    if (now - lastSoundTime > silenceThreshold) {
                        noteHistory = [];
                        noteFrequencies = {};
                        recentNotes = [];
                        detectedKeyLocked = false;
                        lockedKey = null;
                        lockedKeyConfidence = 0;
                        document.getElementById('noteTrailList').innerHTML = '';
                        showToast('New song detected - Resetting...');
                        console.log('Auto-reset: New song detected after 5 seconds of silence');
                    }
                    lastSoundTime = now;
                    
                    addToHistory(note);
                    updateKeyDetection();
                }
            }
        }

        function autoCorrelate(buffer, sampleRate) {
            const SIZE = buffer.length;
            const MAX_SAMPLES = Math.floor(SIZE / 2);
            let best_offset = -1;
            let best_correlation = 0;
            let rms = 0;
            let foundGoodCorrelation = false;

            for (let i = 0; i < SIZE; i++) {
                const val = buffer[i];
                rms += val * val;
            }
            rms = Math.sqrt(rms / SIZE);
            
            if (rms < 0.01) return -1;

            let lastCorrelation = 1;
            for (let offset = 1; offset < MAX_SAMPLES; offset++) {
                let correlation = 0;

                for (let i = 0; i < MAX_SAMPLES; i++) {
                    correlation += Math.abs((buffer[i]) - (buffer[i + offset]));
                }
                correlation = 1 - (correlation / MAX_SAMPLES);
                
                if (correlation > 0.9 && correlation > lastCorrelation) {
                    foundGoodCorrelation = true;
                    if (correlation > best_correlation) {
                        best_correlation = correlation;
                        best_offset = offset;
                    }
                }
                lastCorrelation = correlation;
            }
            
            if (foundGoodCorrelation && best_offset > 0) {
                return sampleRate / best_offset;
            }
            return -1;
        }

        function frequencyToNote(frequency) {
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            const noteIndex = Math.round(noteNum) + 69;
            const noteName = noteStrings[noteIndex % 12];
            const octave = Math.floor(noteIndex / 12) - 1;
            return noteName;
        }

        function calculateConfidence(buffer) {
            let sum = 0;
            for (let i = 0; i < buffer.length; i++) {
                sum += buffer[i] * buffer[i];
            }
            const rms = Math.sqrt(sum / buffer.length);
            return Math.min(rms * 20, 1);
        }

        function updateDisplay(note, frequency, confidence) {
            document.getElementById('currentNote').textContent = note;
            document.getElementById('frequency').textContent = frequency.toFixed(2) + ' Hz';
            
            const confidencePercent = (confidence * 100).toFixed(0);
            document.getElementById('confidence').textContent = confidencePercent + '%';
            document.getElementById('confidenceFill').style.width = confidencePercent + '%';
        }

        function detectChord(recentNotes) {
            if (recentNotes.length < 4) return null;
            
            // Get unique notes from recent history
            const uniqueNotes = [...new Set(recentNotes)];
            
            if (uniqueNotes.length < 2) return null;
            
            // Try to match against chord definitions
            let bestMatch = { chord: null, score: 0 };
            
            for (const [chordName, chordNotes] of Object.entries(chordDefinitions)) {
                let matchScore = 0;
                
                // Count how many chord notes are present in our recent notes
                chordNotes.forEach(chordNote => {
                    if (uniqueNotes.includes(chordNote)) {
                        matchScore++;
                    }
                });
                
                // Calculate match percentage
                const matchPercentage = matchScore / chordNotes.length;
                
                // Need at least 66% match (2 out of 3 notes for triads)
                if (matchPercentage >= 0.66 && matchScore > bestMatch.score) {
                    bestMatch = { chord: chordName, score: matchScore };
                }
            }
            
            return bestMatch.chord;
        }

        function highlightChordKeys(chordName) {
            // Clear previous active keys
            clearAllActiveKeys();
            
            // Get the notes for this chord
            const chordNotes = chordDefinitions[chordName];
            
            if (!chordNotes) return;
            
            // Highlight all keys in the chord
            chordNotes.forEach(note => {
                const key = document.querySelector(`[data-note="${note}"]`);
                if (key) {
                    key.classList.add('active');
                }
            });
            
            // Auto-clear after 400ms
            setTimeout(() => {
                clearAllActiveKeys();
            }, 400);
        }

        function highlightKey(note) {
            // Clear previous active key timeout
            if (currentActiveKey && keyTimeouts[currentActiveKey]) {
                clearTimeout(keyTimeouts[currentActiveKey]);
            }
            
            // Remove active class from all keys
            clearAllActiveKeys();
            
            // Find and activate the current key
            const key = document.querySelector(`[data-note="${note}"]`);
            if (key) {
                key.classList.add('active');
                currentActiveKey = note;
                
                // Auto-deactivate after 300ms
                keyTimeouts[note] = setTimeout(() => {
                    key.classList.remove('active');
                    if (currentActiveKey === note) {
                        currentActiveKey = null;
                    }
                }, 300);
            }
        }

        function clearAllActiveKeys() {
            document.querySelectorAll('.key.active').forEach(key => {
                key.classList.remove('active');
            });
            currentActiveKey = null;
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            
            toastMessage.textContent = message;
            
            // Reset and show
            toast.classList.remove('show');
            setTimeout(() => {
                toast.classList.add('show');
            }, 50);
            
            // Hide after 2.5 seconds
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2500);
        }

        function addToHistory(note) {
            noteHistory.push(note);
            if (noteHistory.length > 50) {
                noteHistory.shift();
            }
            
            noteFrequencies[note] = (noteFrequencies[note] || 0) + 1;
            
            const trailList = document.getElementById('noteTrailList');
            const bubble = document.createElement('div');
            bubble.className = 'note-bubble';
            bubble.textContent = note;
            trailList.insertBefore(bubble, trailList.firstChild);
            
            if (trailList.children.length > 30) {
                trailList.removeChild(trailList.lastChild);
            }
        }

        function updateKeyDetection() {
            if (Object.keys(noteFrequencies).length < 3) {
                document.getElementById('detectedKey').textContent = 'Analyzing...';
                return;
            }
            
            const detectedNotes = Object.keys(noteFrequencies)
                .sort((a, b) => noteFrequencies[b] - noteFrequencies[a])
                .slice(0, 7);
            
            let bestMatch = { key: "Unknown", score: 0, totalNotes: 0 };
            
            for (const [keyName, keyNotes] of Object.entries(keySignatures)) {
                let matchScore = 0;
                let totalNotes = 0;
                
                detectedNotes.forEach(note => {
                    totalNotes += noteFrequencies[note];
                    if (keyNotes.includes(note)) {
                        matchScore += noteFrequencies[note];
                    }
                });
                
                if (matchScore > bestMatch.score) {
                    bestMatch = { 
                        key: keyName, 
                        score: matchScore,
                        totalNotes: totalNotes
                    };
                }
            }
            
            // Calculate confidence percentage
            const confidence = bestMatch.totalNotes > 0 
                ? (bestMatch.score / bestMatch.totalNotes) * 100 
                : 0;
            
            // Lock logic: Lock at 95%+ confidence
            if (!detectedKeyLocked && confidence >= 95) {
                detectedKeyLocked = true;
                lockedKey = bestMatch.key;
                lockedKeyConfidence = confidence;
                document.getElementById('detectedKey').innerHTML = bestMatch.key + 
                    ' <span class="key-locked-indicator">ðŸ”’ Locked</span>';
                showToast(`Key locked: ${bestMatch.key} (${confidence.toFixed(0)}% confident)`);
                console.log(`Key locked at ${confidence.toFixed(0)}% confidence: ${bestMatch.key}`);
            } 
            // Only update if not locked OR new key has 90%+ confidence
            else if (!detectedKeyLocked) {
                // Not locked yet, update normally
                if (bestMatch.score > 0) {
                    document.getElementById('detectedKey').textContent = bestMatch.key;
                }
            } 
            else if (detectedKeyLocked && bestMatch.key !== lockedKey && confidence >= 90) {
                // Locked but detected a different key with high confidence
                detectedKeyLocked = true; // Re-lock with new key
                lockedKey = bestMatch.key;
                lockedKeyConfidence = confidence;
                document.getElementById('detectedKey').innerHTML = bestMatch.key + 
                    ' <span class="key-locked-indicator">ðŸ”’ Locked</span>';
                showToast(`Key changed: ${bestMatch.key} (${confidence.toFixed(0)}% confident)`);
                console.log(`Key changed to ${bestMatch.key} at ${confidence.toFixed(0)}% confidence`);
            }
            // If locked, keep showing the locked key
            else if (detectedKeyLocked) {
                document.getElementById('detectedKey').innerHTML = lockedKey + 
                    ' <span class="key-locked-indicator">ðŸ”’ Locked</span>';
            }
        }
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        // Register service worker for PWA offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed:', err);
                    });
            });
        }
    </script>
</body>
</html>
